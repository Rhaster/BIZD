-- Wszystkie tabele 
-- Stworzenie tabeli kursy walut 
CREATE TABLE kursy_walut1 (
    kod_waluty VARCHAR2(3) PRIMARY KEY,
    kurs NUMBER NOT NULL,
    data_aktualizacji DATE DEFAULT SYSDATE
);
-- Stworzenie archiwum kursow walut
CREATE TABLE archiwum_kursow_walut (
    id_archiwum NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    kod_waluty VARCHAR2(3) NOT NULL,
    kurs NUMBER NOT NULL,
    data_archiwizacji DATE DEFAULT SYSDATE
);
-- Stworzenie tabeli logi operacji 
CREATE TABLE logi_operacji (
    id_logu NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    typ_logu VARCHAR2(50),
    wiadomosc_logu VARCHAR2(4000),
    data_utworzenia DATE DEFAULT SYSDATE
);
-- Stworzenie tabeli podsumowania okresow
CREATE TABLE podsumowania_okresowe (
    id_podsumowania NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    typ_okresu VARCHAR2(10) CHECK (typ_okresu IN ('MIESIAC', 'KWARTAL', 'ROK')),
    okres VARCHAR2(10), -- np. '2025-Q1'
    sredni_kurs NUMBER,
    kod_waluty VARCHAR2(3),
    data_utworzenia DATE DEFAULT SYSDATE
);

-- Stworzenie tabeli przechowywujących usunięte dane z archiwum 
CREATE TABLE usuniete_dane_archiwum (
    id_usuniecia NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    kod_waluty VARCHAR2(3) NOT NULL,
    kurs NUMBER NOT NULL,
    data_archiwizacji DATE NOT NULL,
    data_usuniecia DATE DEFAULT SYSDATE
);
-- Stworzenie tabeli przechowywujacej dane o zmianach w kursach 
CREATE TABLE tendencje (
    id_tendencji NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- Unikalny identyfikator tendencji
    kod_waluty VARCHAR2(3) NOT NULL, -- Kod waluty (np. USD, EUR)
    wartosc VARCHAR2(10) CHECK (wartosc IN ('WZROST', 'SPADEK', 'BRAK ZMIAN')) NOT NULL, -- Tendencja: wzrost, spadek lub brak zmian
    procentowa_roznica NUMBER(10, 4) NOT NULL, -- Procentowa zmiana kursu względem poprzedniego kursu
    data_utworzenia DATE DEFAULT SYSDATE -- Data utworzenia wpisu w tabeli tendencji
);
-- Stworzenie tabeli zapisujacej archiwalne zmiany w tendencjach 
CREATE TABLE archiwum_tendencji (
    id_archiwum NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- Unikalny identyfikator archiwizacji
    kod_waluty VARCHAR2(3) NOT NULL, -- Kod waluty (np. USD, EUR)
    wartosc VARCHAR2(10) CHECK (wartosc IN ('WZROST', 'SPADEK', 'BRAK ZMIAN')) NOT NULL, -- Tendencja
    procentowa_roznica NUMBER(10, 4) NOT NULL, -- Procentowa zmiana kursu
    data_utworzenia DATE NOT NULL, -- Data utworzenia wpisu w tabeli tendencje
    data_archiwizacji DATE DEFAULT SYSDATE -- Data przeniesienia do archiwum
);
-- Stworzenie tabeli lista_zestawien
CREATE TABLE lista_zestawien (
    id_zestawienia NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nazwa VARCHAR2(100) NOT NULL,   -- Nazwa zestawienia np. "Zestawienie Styczeń 2025"
    data_utworzenia DATE DEFAULT SYSDATE
);
-- Stworzenie tabeli zestawienia 
CREATE TABLE zestawienia (
    id_zestawienia NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_lista_zestawien NUMBER NOT NULL, -- Klucz obcy do `lista_zestawien`
    kod_waluty VARCHAR2(3) NOT NULL,    -- Waluta dla której generujemy zestawienie
    data_od DATE NOT NULL,              -- Początek okresu
    data_do DATE NOT NULL,              -- Koniec okresu
    sredni_kurs NUMBER NOT NULL,        -- Średni kurs waluty w danym okresie
    najnizszy_kurs NUMBER,              -- Najniższy kurs w danym okresie
    data_najnizszego DATE,              -- Data najniższego kursu
    najwyzszy_kurs NUMBER,              -- Najwyższy kurs w danym okresie
    data_najwyzszego DATE,              -- Data najwyższego kursu
    FOREIGN KEY (id_lista_zestawien) REFERENCES lista_zestawien(id_zestawienia) ON DELETE CASCADE
);
-- tabela do usunietych kursow 
CREATE TABLE usuniete_dane_kursy (
    id_usuniecia NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    kod_waluty VARCHAR2(3) NOT NULL,
    kurs NUMBER NOT NULL,
    data_aktualizacji DATE NOT NULL,
    data_usuniecia DATE DEFAULT SYSDATE
);
-- Triggery 
-- Archiwizacja usunietych kursow z archiwum 
-- Trigger do usunietych danych z archiwóm 

CREATE OR REPLACE TRIGGER trg_archiwizacja_usunietych_archiwum
BEFORE DELETE ON archiwum_kursow_walut
FOR EACH ROW
DECLARE
    PRAGMA AUTONOMOUS_TRANSACTION;  -- Umożliwia niezależne zapisanie logów
    v_exists NUMBER;  -- Sprawdzenie, czy tabela `usuniete_dane_archiwum` istnieje
BEGIN
    -- Sprawdzenie, czy tabela `usuniete_dane_archiwum` istnieje
    BEGIN
        SELECT COUNT(*) INTO v_exists FROM user_tables WHERE table_name = 'USUNIETE_DANE_ARCHIWUM';
        IF v_exists = 0 THEN
            loguj_informacje('ERROR', 'Tabela usuniete_dane_archiwum nie istnieje!');
            RETURN;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            loguj_informacje('ERROR', 'Błąd podczas sprawdzania istnienia tabeli usuniete_dane_archiwum: ' || SQLERRM);
            RETURN;
    END;

    -- Sprawdzenie, czy kolumny istnieją w `archiwum_kursow_walut`
    BEGIN
        SELECT COUNT(*) INTO v_exists 
        FROM all_tab_columns 
        WHERE table_name = 'ARCHIWUM_KURSOW_WALUT' 
        AND column_name IN ('KOD_WALUTY', 'KURS', 'DATA_ARCHIWIZACJI');

        IF v_exists < 3 THEN
            loguj_informacje('ERROR', 'Brak wymaganych kolumn w tabeli archiwum_kursow_walut!');
            RETURN;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            loguj_informacje('ERROR', 'Błąd podczas sprawdzania kolumn w archiwum_kursow_walut: ' || SQLERRM);
            RETURN;
    END;

    -- Przeniesienie usuwanego rekordu do tabeli usuniete_dane_archiwum
    BEGIN
        INSERT INTO usuniete_dane_archiwum (kod_waluty, kurs, data_archiwizacji, data_usuniecia)
        VALUES (:OLD.kod_waluty, :OLD.kurs, :OLD.data_archiwizacji, SYSDATE);

        -- Logowanie operacji usunięcia
        loguj_informacje('INFO', 'Usunięto archiwalny kurs waluty ' || :OLD.kod_waluty || ', kurs: ' || :OLD.kurs);

        COMMIT;  -- Potrzebne dla autonomicznej transakcji
    EXCEPTION
        WHEN OTHERS THEN
            loguj_informacje('ERROR', 'Błąd w triggerze trg_archiwizacja_usunietych_archiwum: ' || SQLERRM);
            ROLLBACK;  -- Wycofanie transakcji, jeśli coś poszło nie tak
    END;
END;
/
-- Test triggera 
INSERT INTO archiwum_kursow_walut (kod_waluty, kurs, data_archiwizacji)
VALUES ('DUP', 1.30, TO_DATE('10/01/24', 'DD/MM/YY'));

COMMIT;
Select *FROM archiwum_kursow_walut WHERE kod_waluty = 'DUP';
DELETE FROM archiwum_kursow_walut WHERE kod_waluty = 'DUP';
COMMIT;
SELECT * FROM usuniete_dane_archiwum ORDER BY data_usuniecia DESC;

-- Trigger Dodanie do tendencji danych przy nowych kursach w bazie 

CREATE OR REPLACE TRIGGER trg_tendencje
AFTER INSERT ON kursy_walut1 -- Trigger uruchamia się po dodaniu nowego kursu do kursy_walut1
FOR EACH ROW
DECLARE
    PRAGMA AUTONOMOUS_TRANSACTION; -- Zapewnia, że archiwizacja i logowanie nie blokują transakcji głównej
    v_poprzedni_kurs NUMBER; -- Poprzedni kurs waluty
    v_procentowa_roznica NUMBER(10,4); -- Obliczona procentowa różnica
    v_wartosc VARCHAR2(20); -- Typ zmiany kursu (WZROST, SPADEK, BRAK ZMIAN)
BEGIN
    -- Pobranie poprzedniego kursu waluty (jeśli istnieje)
    BEGIN
        SELECT kurs INTO v_poprzedni_kurs
        FROM kursy_walut1
        WHERE kod_waluty = :NEW.kod_waluty
        AND data_aktualizacji < :NEW.data_aktualizacji
        ORDER BY data_aktualizacji DESC
        FETCH FIRST 1 ROW ONLY;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            v_poprzedni_kurs := NULL; -- Jeśli brak poprzedniego kursu, ustawiamy NULL
    END;

    -- Obliczenie procentowej różnicy kursów
    IF v_poprzedni_kurs IS NOT NULL THEN
        v_procentowa_roznica := ROUND((( :NEW.kurs - v_poprzedni_kurs ) / v_poprzedni_kurs ) * 100, 4);

        -- Określenie tendencji kursu
        IF v_procentowa_roznica > 0 THEN
            v_wartosc := 'WZROST';
        ELSIF v_procentowa_roznica < 0 THEN
            v_wartosc := 'SPADEK';
        ELSE
            v_wartosc := 'BRAK ZMIAN';
        END IF;
    ELSE
        -- Brak wcześniejszego kursu - pierwszy wpis, domyślnie BRAK ZMIAN
        v_procentowa_roznica := 0;
        v_wartosc := 'BRAK ZMIAN';
    END IF;

    -- 🔹 Archiwizacja starej tendencji przed dodaniem nowej
    BEGIN
        INSERT INTO archiwum_tendencji (kod_waluty, wartosc, procentowa_roznica, data_utworzenia, data_archiwizacji)
        SELECT kod_waluty, wartosc, procentowa_roznica, data_utworzenia, SYSDATE
        FROM tendencje
        WHERE kod_waluty = :NEW.kod_waluty;

        -- 🔹 Usunięcie starej tendencji
        DELETE FROM tendencje WHERE kod_waluty = :NEW.kod_waluty;

        -- 🔹 Wstawienie nowej tendencji na podstawie nowego kursu
        INSERT INTO tendencje (kod_waluty, wartosc, procentowa_roznica, data_utworzenia)
        VALUES (:NEW.kod_waluty, v_wartosc, v_procentowa_roznica, SYSDATE);

        -- 🔹 Logowanie operacji
        loguj_informacje('INFO', 'Zaktualizowano tendencję dla waluty ' || :NEW.kod_waluty || 
                         ' - ' || v_wartosc || ' (' || v_procentowa_roznica || '%)');

        COMMIT; -- Konieczne dla autonomicznej transakcji
    EXCEPTION
        WHEN OTHERS THEN
            loguj_informacje('ERROR', 'Błąd w triggerze trg_tendencje: ' || SQLERRM);
            ROLLBACK;
    END;
END;
/
-- wywolanie to odpalenie skrtpu i wyslanie jakis danych 



Select *FROM logi_operacji ;
Select *FROM  TENDENCJE;
Select *FROM ARCHIWUM_TENDENCJI;
Select *FROM kursy_walut1 WHERE kod_waluty = 'USD';

--Trigger archiwizacja starych kursów
CREATE OR REPLACE TRIGGER archiwizuj_przed_usunieciem1
BEFORE DELETE ON kursy_walut1
FOR EACH ROW
DECLARE
    PRAGMA AUTONOMOUS_TRANSACTION;  -- Umożliwia niezależne zapisywanie do logów i archiwum
BEGIN
    BEGIN
        -- 🔹 Archiwizacja rekordu przed usunięciem
        INSERT INTO archiwum_kursow_walut (kod_waluty, kurs, data_archiwizacji)
        VALUES (:OLD.kod_waluty, :OLD.kurs, SYSDATE);

        -- 🔹 Logowanie sukcesu
        loguj_informacje('INFO', 'Zarchiwizowano kurs waluty ' || :OLD.kod_waluty);

        -- 🔹 Zatwierdzenie transakcji autonomicznej
        COMMIT;
    EXCEPTION
        WHEN DUP_VAL_ON_INDEX THEN
            loguj_informacje('WARNING', 'Próba archiwizacji duplikatu kursu waluty ' || :OLD.kod_waluty);
            ROLLBACK;  -- Cofnięcie w przypadku problemów
        WHEN OTHERS THEN
            loguj_informacje('ERROR', 'Błąd archiwizacji kursu waluty ' || :OLD.kod_waluty || ': ' || SQLERRM);
            ROLLBACK;
    END;
END;
/

-- Testowanie
SELECT * FROM kursy_walut1 WHERE kod_waluty = 'USD';
SELECT * FROM archiwum_kursow_walut WHERE kod_waluty = 'USD';

--Funkcja do pobrania wsystkich kursów danej waluty z aktualnych danych i archiwum 
CREATE OR REPLACE FUNCTION pobierz_kursy_waluty(p_kod_waluty IN VARCHAR2)
RETURN SYS_REFCURSOR
IS
    v_cursor SYS_REFCURSOR;
    v_count NUMBER;
BEGIN
    IF p_kod_waluty IS NULL THEN
        loguj_informacje('ERROR', 'Kod waluty nie może być NULL');
        RAISE_APPLICATION_ERROR(-20001, 'Kod waluty nie może być NULL');
    END IF;

    -- Sprawdzenie, czy w ogóle istnieją dane dla podanej waluty
    SELECT COUNT(*) INTO v_count
    FROM (
        SELECT kod_waluty FROM kursy_walut1 WHERE kod_waluty = p_kod_waluty
        UNION ALL
        SELECT kod_waluty FROM archiwum_kursow_walut WHERE kod_waluty = p_kod_waluty
    );

    IF v_count = 0 THEN
        loguj_informacje('WARNING', 'Brak danych dla kodu waluty: ' || p_kod_waluty);
        RAISE_APPLICATION_ERROR(-20002, 'Brak danych dla podanego kodu waluty');
    END IF;

    loguj_informacje('INFO', 'Pobieranie kursów dla waluty: ' || p_kod_waluty);

    OPEN v_cursor FOR
        SELECT kod_waluty, kurs, data_aktualizacji AS data_operacji, 'Aktualny' AS zrodlo
        FROM kursy_walut1
        WHERE kod_waluty = p_kod_waluty
        
        UNION ALL
        
        SELECT kod_waluty, kurs, data_archiwizacji AS data_operacji, 'Archiwum' AS zrodlo
        FROM archiwum_kursow_walut
        WHERE kod_waluty = p_kod_waluty;

    RETURN v_cursor;
EXCEPTION
    WHEN OTHERS THEN
        loguj_informacje('ERROR', 'Błąd w funkcji pobierz_kursy_waluty: ' || SQLERRM);
        RAISE_APPLICATION_ERROR(-20003, 'Wystąpił nieoczekiwany błąd: ' || SQLERRM);
END pobierz_kursy_waluty;
/



DECLARE
    v_cursor SYS_REFCURSOR;
    v_kod_waluty VARCHAR2(3) := 'USD'; -- Przykładowy kod waluty
    v_kurs NUMBER;
    v_data_operacji DATE;
    v_zrodlo VARCHAR2(20);
BEGIN
    v_cursor := pobierz_kursy_waluty(v_kod_waluty);

    LOOP
        FETCH v_cursor INTO v_kod_waluty, v_kurs, v_data_operacji, v_zrodlo;
        EXIT WHEN v_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Kod: ' || v_kod_waluty || ', Kurs: ' || v_kurs || ', Data: ' || v_data_operacji || ', Źródło: ' || v_zrodlo);
    END LOOP;

    CLOSE v_cursor;
END;
/

Select *From logi_operacji;
Select *From KURSY_WALUT1;

SET SERVEROUTPUT ON;



-- Funkcja pobierz sredni kurs walut( od podanego do okreslonego okresu, jedna waluta) 
CREATE OR REPLACE FUNCTION pobierz_sredni_kurs_waluty(
    p_kod_waluty VARCHAR2, -- Kod waluty, dla której obliczamy średni kurs
    p_data_od VARCHAR2, -- Początkowa data zakresu
    p_data_do VARCHAR2 -- Końcowa data zakresu
) RETURN NUMBER
IS
    v_sredni_kurs NUMBER := NULL; -- Zmienna przechowująca wynikowy średni kurs
    v_exists NUMBER := 0; -- Flaga sprawdzająca, czy waluta istnieje w bazie
    v_data_od DATE; -- Zmienna przechowująca sformatowaną datę początkową
    v_data_do DATE; -- Zmienna przechowująca sformatowaną datę końcową
BEGIN
    -- Konwersja parametrów na format daty zgodny z tabelami
    BEGIN
        v_data_od := TO_DATE(p_data_od, 'DD/MM/YY'); -- Konwersja daty początkowej
        v_data_do := TO_DATE(p_data_do, 'DD/MM/YY'); -- Konwersja daty końcowej
    EXCEPTION
        WHEN OTHERS THEN
            loguj_informacje('ERROR', 'Nieprawidłowy format daty: ' || p_data_od || ' - ' || p_data_do); -- Logowanie błędu formatu daty
            RETURN NULL; -- Zwracamy NULL w przypadku błędu
    END;

    -- Sprawdzenie, czy waluta istnieje w kursy_walut1 lub archiwum_kursow_walut
    BEGIN
        SELECT COUNT(*) INTO v_exists 
        FROM (
            SELECT 1 FROM kursy_walut1 WHERE kod_waluty = p_kod_waluty
            UNION ALL
            SELECT 1 FROM archiwum_kursow_walut WHERE kod_waluty = p_kod_waluty
        );

        IF v_exists = 0 THEN
            loguj_informacje('ERROR', 'Brak kursu waluty ' || p_kod_waluty || ' w bazie.'); -- Logowanie braku waluty w bazie
            RETURN NULL; -- Zwracamy NULL, jeśli waluty nie ma
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL; -- W przypadku błędu zwracamy NULL
    END;

    -- Pobranie średniego kursu waluty (uwzględniając TRUNC)
    BEGIN
        SELECT AVG(kurs) INTO v_sredni_kurs
        FROM (
            SELECT kurs FROM kursy_walut1 
            WHERE kod_waluty = p_kod_waluty
            AND TRUNC(data_aktualizacji) BETWEEN v_data_od AND v_data_do
            UNION ALL
            SELECT kurs FROM archiwum_kursow_walut 
            WHERE kod_waluty = p_kod_waluty
            AND TRUNC(data_archiwizacji) BETWEEN v_data_od AND v_data_do
        );

        -- Jeśli wynik jest NULL, logujemy
        IF v_sredni_kurs IS NULL THEN
            loguj_informacje('ERROR', 'Brak danych dla waluty ' || p_kod_waluty || ' w podanym zakresie.'); -- Logowanie braku danych
            RETURN NULL; -- Zwracamy NULL, jeśli nie znaleziono danych
        END IF;

        -- Logowanie sukcesu
        loguj_informacje('INFO', 'Pobrano średni kurs waluty ' || p_kod_waluty || 
            ' za okres ' || p_data_od || ' - ' || p_data_do);

    EXCEPTION
        WHEN OTHERS THEN
            loguj_informacje('ERROR', 'Błąd w funkcji pobierz_sredni_kurs_waluty: ' || SQLERRM); -- Logowanie błędu funkcji
            RETURN NULL; -- Zwracamy NULL w przypadku błędu
    END;

    RETURN v_sredni_kurs; -- Zwracamy obliczony średni kurs waluty
END pobierz_sredni_kurs_waluty;
/

DECLARE
    v_sredni_kurs NUMBER;
BEGIN
    v_sredni_kurs := pobierz_sredni_kurs_waluty('USD', '01/01/24', '31/12/25'); -- Przykładowe parametry (kod waluty, zakres dat)
    
    IF v_sredni_kurs IS NULL THEN
        DBMS_OUTPUT.PUT_LINE('Brak danych dla podanej waluty lub wystąpił błąd.');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Średni kurs USD: ' || v_sredni_kurs);
    END IF;
END;
/

SELECT * FROM kursy_walut1 WHERE kod_waluty = 'USD';
SELECT * FROM archiwum_kursow_walut WHERE kod_waluty = 'USD';
SET SERVEROUTPUT ON;

-- Dodanie i aktualizacja kursu walut 


create or replace PROCEDURE DOD_LUB_AKTUALIZACJA_KW(
    p_kod_waluty VARCHAR2,
    p_kurs NUMBER
) AS
    v_exists NUMBER := 0;
BEGIN
    -- Sprawdzenie poprawności kodu waluty
    IF NOT REGEXP_LIKE(p_kod_waluty, '^[A-Z]{3}$') THEN
        loguj_informacje('ERROR', 'Nieprawidłowy kod waluty: ' || p_kod_waluty);
        RAISE_APPLICATION_ERROR(-20002, 'Kod waluty musi składać się z 3 dużych liter.');
    END IF;

    -- Sprawdzenie poprawności kursu
    IF NOT sprawdz_poprawnosc_kursu(p_kurs) THEN
        loguj_informacje('ERROR', 'Nieprawidłowa wartość kursu dla ' || p_kod_waluty);
        RAISE_APPLICATION_ERROR(-20001, 'Kurs waluty musi być dodatni.');
    END IF;

    -- Sprawdzenie, czy waluta istnieje
    BEGIN
        SELECT 1 INTO v_exists FROM KURSY_WALUT1 WHERE kod_waluty = p_kod_waluty FETCH FIRST ROW ONLY;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            v_exists := 0;
    END;

    -- Jeśli istnieje, aktualizujemy kurs
    IF v_exists > 0 THEN
        BEGIN
            UPDATE KURSY_WALUT1
            SET kurs = p_kurs, data_aktualizacji = SYSDATE
            WHERE kod_waluty = p_kod_waluty;
            loguj_informacje('INFO', 'Zaktualizowano kurs waluty ' || p_kod_waluty);
        EXCEPTION
            WHEN OTHERS THEN
                loguj_informacje('ERROR', 'Nie udało się zaktualizować kursu: ' || SQLERRM);
        END;
    ELSE
        -- Jeśli nie istnieje, dodajemy nowy wpis
        BEGIN
            INSERT INTO KURSY_WALUT1 (kod_waluty, kurs, data_aktualizacji)
            VALUES (p_kod_waluty, p_kurs, SYSDATE);
            loguj_informacje('INFO', 'Dodano nowy kurs waluty ' || p_kod_waluty);
        EXCEPTION
            WHEN DUP_VAL_ON_INDEX THEN
                loguj_informacje('ERROR', 'Próba dodania duplikatu: ' || SQLERRM);
            WHEN OTHERS THEN
                loguj_informacje('ERROR', 'Nie udało się dodać kursu: ' || SQLERRM);
        END;
    END IF;

    -- Zakończenie transakcji (bezpieczeństwo)
    COMMIT;

EXCEPTION
    WHEN OTHERS THEN
        loguj_informacje('ERROR', 'Błąd w procedurze: ' || SQLERRM);
        RAISE;
END;


-- Testy dodawania i aktualizowania kuru walut 

BEGIN
    DOD_LUB_AKTUALIZACJA_KW('USD', 1.25);
    DOD_LUB_AKTUALIZACJA_KW('EUR', 0.95);
    DOD_LUB_AKTUALIZACJA_KW('GBP', 0.85);
END;
/
SELECT * FROM kursy_walut1 WHERE kod_waluty IN('USD','EUR','GBP');


BEGIN
    -- Poprawne dodanie kursu waluty
    DOD_LUB_AKTUALIZACJA_KW('USD', 1.4);

    -- Próba dodania błędnych kodów walut (za krótkie / za długie)
    DOD_LUB_AKTUALIZACJA_KW('us', 1.25);  -- Niepoprawny kod waluty
    DOD_LUB_AKTUALIZACJA_KW('USDD', 1.25); -- Za długi kod waluty

    -- Próba dodania ujemnego kursu
    DOD_LUB_AKTUALIZACJA_KW('USD', -1.0);

EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Błąd: ' || SQLERRM);
END;
/
SELECT * FROM kursy_walut1 WHERE kod_waluty IN('USD','EUR','GBP');
SELECT *FROM logi_operacji;
 -- Ogólne testy funkcji loguj informacje , dodawania, sprawdzania poprawnosci kursu 
--a) Dodawanie, usuwanie, aktualizacja rekordów

SET SERVEROUTPUT ON;
-- Usun kurs walut
CREATE OR REPLACE PROCEDURE usun_kurs_waluty1(
    p_kod_waluty VARCHAR2
) AS
    v_count NUMBER;
    v_kurs NUMBER;
    v_data_aktualizacji DATE;
BEGIN
    -- 🔹 Sprawdzenie, czy podana waluta istnieje w `kursy_walut1`
    SELECT COUNT(*) INTO v_count FROM kursy_walut1 WHERE kod_waluty = p_kod_waluty;

    IF v_count = 0 THEN
        -- 🔹 Logowanie i zgłoszenie błędu, jeśli waluta nie istnieje
        loguj_informacje('WARNING', 'Próba usunięcia kursu dla nieistniejącej waluty: ' || p_kod_waluty);
        RAISE_APPLICATION_ERROR(-20001, 'Waluta ' || p_kod_waluty || ' nie istnieje w tabeli kursy_walut1.');
    END IF;

    -- 🔹 Pobranie danych kursu przed usunięciem
    SELECT kurs, data_aktualizacji INTO v_kurs, v_data_aktualizacji
    FROM kursy_walut1
    WHERE kod_waluty = p_kod_waluty;

    INSERT INTO usuniete_dane_kursy (kod_waluty, kurs, data_aktualizacji, data_usuniecia)
    VALUES (p_kod_waluty, v_kurs, v_data_aktualizacji, SYSDATE);


    -- 🔹 Usunięcie kursu waluty
    DELETE FROM kursy_walut1 WHERE kod_waluty = p_kod_waluty;

    -- 🔹 Logowanie sukcesu
    loguj_informacje('INFO', 'Usunięto kurs waluty ' || p_kod_waluty);

    -- 🔹 Zatwierdzenie transakcji
    COMMIT;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        loguj_informacje('ERROR', 'Błąd: Brak danych w tabeli kursy_walut1 dla waluty ' || p_kod_waluty);
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20002, 'Brak danych do usunięcia.');
    WHEN OTHERS THEN
        loguj_informacje('ERROR', 'Błąd podczas usuwania kursu waluty ' || p_kod_waluty || ': ' || SQLERRM);
        ROLLBACK;
        RAISE;
END;
/
-- Testowanie 
SELECT * FROM kursy_walut1 WHERE kod_waluty = 'USD';
SELECT * FROM usuniete_dane_kursy WHERE kod_waluty = 'USD';
BEGIN
    usun_kurs_waluty1('USD');
END;
/
SELECT * FROM kursy_walut1 WHERE kod_waluty = 'USD';
SELECT * FROM usuniete_dane_kursy WHERE kod_waluty = 'USD';
SELECT * FROM logi_operacji ORDER BY data_utworzenia DESC;
-- funkcja sprawdz poprawnosc kursu 
create or replace FUNCTION sprawdz_poprawnosc_kursu(
    p_kurs NUMBER
) RETURN BOOLEAN AS
BEGIN
    RETURN p_kurs > 0;
END;


-- Sprawdzenie funkcji sprawdz poprawnosc kursu 

DECLARE
    v_kurs NUMBER := -5;  -- Testowy kurs (ujemny, co powinno spowodować błąd)
    v_wynik BOOLEAN;
BEGIN
    -- Sprawdzenie, czy kurs jest poprawny
    v_wynik := sprawdz_poprawnosc_kursu(v_kurs);

    IF v_wynik THEN
        DBMS_OUTPUT.PUT_LINE('✅ Kurs ' || v_kurs || ' jest poprawny.');
    ELSE
        DBMS_OUTPUT.PUT_LINE('❌ Kurs ' || v_kurs || ' jest niepoprawny.');
    END IF;
END;
/
SET SERVEROUTPUT ON;



-- Procedura Zestawienia

CREATE OR REPLACE PROCEDURE dodaj_zestawienie_walutowe(
    p_id_lista_zestawien NUMBER,  
    p_kod_waluty VARCHAR2,
    p_data_od DATE,
    p_data_do DATE
) AS
    v_sredni_kurs NUMBER;
    v_najnizszy_kurs NUMBER;
    v_data_najnizszego DATE;
    v_najwyzszy_kurs NUMBER;
    v_data_najwyzszego DATE;
    v_count NUMBER;
BEGIN
    -- 🔹 Sprawdzenie czy `p_id_lista_zestawien` istnieje w `lista_zestawien`
    SELECT COUNT(*) INTO v_count FROM lista_zestawien WHERE id_zestawienia = p_id_lista_zestawien;
    IF v_count = 0 THEN
        loguj_informacje('ERROR', 'Nie znaleziono zestawienia o ID ' || p_id_lista_zestawien);
        RAISE_APPLICATION_ERROR(-20004, 'Nie znaleziono zestawienia o ID ' || p_id_lista_zestawien);
    END IF;

    -- 🔹 Sprawdzenie czy `p_kod_waluty` istnieje w `kursy_walut1` lub `archiwum_kursow_walut`
    SELECT COUNT(*) INTO v_count 
    FROM (
        SELECT kod_waluty FROM kursy_walut1 WHERE kod_waluty = p_kod_waluty
        UNION 
        SELECT kod_waluty FROM archiwum_kursow_walut WHERE kod_waluty = p_kod_waluty
    );
    IF v_count = 0 THEN
        loguj_informacje('ERROR', 'Nie znaleziono danych dla waluty: ' || p_kod_waluty);
        RAISE_APPLICATION_ERROR(-20005, 'Nie znaleziono danych dla waluty: ' || p_kod_waluty);
    END IF;

    -- 🔹 Obliczenie średniego kursu (z `kursy_walut1` i `archiwum_kursow_walut`)
    BEGIN
        SELECT AVG(kurs) INTO v_sredni_kurs
        FROM (
            SELECT kurs FROM kursy_walut1 WHERE kod_waluty = p_kod_waluty AND data_aktualizacji BETWEEN p_data_od AND p_data_do
            UNION ALL
            SELECT kurs FROM archiwum_kursow_walut WHERE kod_waluty = p_kod_waluty AND data_archiwizacji BETWEEN p_data_od AND p_data_do
        );

        IF v_sredni_kurs IS NULL THEN
            loguj_informacje('WARNING', 'Brak danych o kursach dla ' || p_kod_waluty || ' w okresie ' || TO_CHAR(p_data_od, 'YYYY-MM-DD') || ' - ' || TO_CHAR(p_data_do, 'YYYY-MM-DD'));
            RAISE_APPLICATION_ERROR(-20002, 'Brak danych o kursach w podanym okresie');
        END IF;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            loguj_informacje('WARNING', 'Brak danych o kursach dla ' || p_kod_waluty || ' w okresie ' || TO_CHAR(p_data_od, 'YYYY-MM-DD') || ' - ' || TO_CHAR(p_data_do, 'YYYY-MM-DD'));
            RAISE_APPLICATION_ERROR(-20002, 'Brak danych o kursach w podanym okresie');
    END;

    -- 🔹 Pobranie najniższego kursu i jego daty
    BEGIN
        SELECT kurs, data_aktualizacji INTO v_najnizszy_kurs, v_data_najnizszego
        FROM (
            SELECT kurs, data_aktualizacji FROM kursy_walut1 WHERE kod_waluty = p_kod_waluty AND data_aktualizacji BETWEEN p_data_od AND p_data_do
            UNION ALL
            SELECT kurs, data_archiwizacji FROM archiwum_kursow_walut WHERE kod_waluty = p_kod_waluty AND data_archiwizacji BETWEEN p_data_od AND p_data_do
        )
        ORDER BY kurs ASC, data_aktualizacji ASC
        FETCH FIRST 1 ROW ONLY;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            v_najnizszy_kurs := NULL;
            v_data_najnizszego := NULL;
            loguj_informacje('WARNING', 'Brak danych o najniższym kursie dla ' || p_kod_waluty);
    END;

    -- 🔹 Pobranie najwyższego kursu i jego daty
    BEGIN
        SELECT kurs, data_aktualizacji INTO v_najwyzszy_kurs, v_data_najwyzszego
        FROM (
            SELECT kurs, data_aktualizacji FROM kursy_walut1 WHERE kod_waluty = p_kod_waluty AND data_aktualizacji BETWEEN p_data_od AND p_data_do
            UNION ALL
            SELECT kurs, data_archiwizacji FROM archiwum_kursow_walut WHERE kod_waluty = p_kod_waluty AND data_archiwizacji BETWEEN p_data_od AND p_data_do
        )
        ORDER BY kurs DESC, data_aktualizacji ASC
        FETCH FIRST 1 ROW ONLY;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            v_najwyzszy_kurs := NULL;
            v_data_najwyzszego := NULL;
            loguj_informacje('WARNING', 'Brak danych o najwyższym kursie dla ' || p_kod_waluty);
    END;

    -- 🔹 Wstawienie rekordu do tabeli `zestawienia`
    INSERT INTO zestawienia (id_lista_zestawien, kod_waluty, data_od, data_do, sredni_kurs, 
                             najnizszy_kurs, data_najnizszego, najwyzszy_kurs, data_najwyzszego)
    VALUES (p_id_lista_zestawien, p_kod_waluty, p_data_od, p_data_do, v_sredni_kurs, 
            v_najnizszy_kurs, v_data_najnizszego, v_najwyzszy_kurs, v_data_najwyzszego);

    -- 🔹 Logowanie operacji
    loguj_informacje('INFO', 'Dodano zestawienie dla waluty ' || p_kod_waluty || 
                             ' od ' || TO_CHAR(p_data_od, 'YYYY-MM-DD') || 
                             ' do ' || TO_CHAR(p_data_do, 'YYYY-MM-DD') || 
                             ' - średni kurs: ' || v_sredni_kurs || 
                             ', min: ' || v_najnizszy_kurs || ' (' || TO_CHAR(v_data_najnizszego, 'YYYY-MM-DD') || ')' || 
                             ', max: ' || v_najwyzszy_kurs || ' (' || TO_CHAR(v_data_najwyzszego, 'YYYY-MM-DD') || ')');
    
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        loguj_informacje('ERROR', 'Błąd w procedurze dodaj_zestawienie_walutowe: ' || SQLERRM);
        ROLLBACK;
        RAISE;
END;
/


-- Testowanie 
INSERT INTO lista_zestawien (nazwa) VALUES ('Zestawienie Styczeń 2025') RETURNING id_zestawienia INTO :new_id;
COMMIT;


DECLARE
    v_id_lista_zestawien NUMBER := 1;  -- ID zestawienia, które stworzyliśmy wcześniej
BEGIN
    dodaj_zestawienie_walutowe(v_id_lista_zestawien, 'USD', TO_DATE('2025-01-01', 'YYYY-MM-DD'), TO_DATE('2025-01-31', 'YYYY-MM-DD'));
END;
/


SELECT * FROM zestawienia ORDER BY data_od DESC;

-- Procedura stwórz zestawiania dla wszystkich walut od danego okresu, do danego okresu 


CREATE OR REPLACE PROCEDURE generuj_zestawienia_dla_wszystkich_walut(
    p_nazwa_zestawienia VARCHAR2,  -- Nazwa zestawienia np. "Zestawienie Styczeń 2025"
    p_data_od DATE,
    p_data_do DATE
) AS
    v_id_lista_zestawien NUMBER;
    v_kod_waluty VARCHAR2(3);
    v_count NUMBER;

    -- Kursor pobierający unikalne waluty z obu tabel
    CURSOR c_waluty IS (
        SELECT DISTINCT kod_waluty FROM kursy_walut1
        UNION
        SELECT DISTINCT kod_waluty FROM archiwum_kursow_walut
    );
BEGIN
    -- 🔹 1️⃣ Sprawdzenie poprawności dat
    IF p_data_od > p_data_do THEN
        loguj_informacje('ERROR', 'Błąd: Data OD (' || TO_CHAR(p_data_od, 'YYYY-MM-DD') || ') jest późniejsza niż data DO (' || TO_CHAR(p_data_do, 'YYYY-MM-DD') || ')');
        RAISE_APPLICATION_ERROR(-20001, 'Data OD nie może być późniejsza niż data DO');
    END IF;

    -- 🔹 2️⃣ Sprawdzenie, czy istnieją kursy walutowe w danym zakresie
    SELECT COUNT(*) INTO v_count 
    FROM (
        SELECT kod_waluty FROM kursy_walut1 WHERE data_aktualizacji BETWEEN p_data_od AND p_data_do
        UNION
        SELECT kod_waluty FROM archiwum_kursow_walut WHERE data_archiwizacji BETWEEN p_data_od AND p_data_do
    );
    
    IF v_count = 0 THEN
        loguj_informacje('ERROR', 'Brak danych o kursach w podanym okresie ' || TO_CHAR(p_data_od, 'YYYY-MM-DD') || ' - ' || TO_CHAR(p_data_do, 'YYYY-MM-DD'));
        RAISE_APPLICATION_ERROR(-20002, 'Brak danych o kursach w podanym okresie.');
    END IF;

    -- 🔹 3️⃣ Tworzenie nowego wpisu w `lista_zestawien`
    BEGIN
        INSERT INTO lista_zestawien (nazwa) 
        VALUES (p_nazwa_zestawienia)
        RETURNING id_zestawienia INTO v_id_lista_zestawien;

        COMMIT;

        -- Logowanie operacji
        loguj_informacje('INFO', 'Utworzono nowe zestawienie: ' || p_nazwa_zestawienia || ', ID: ' || v_id_lista_zestawien);
    EXCEPTION
        WHEN OTHERS THEN
            loguj_informacje('ERROR', 'Błąd podczas tworzenia wpisu w lista_zestawien: ' || SQLERRM);
            ROLLBACK;
            RAISE;
    END;

    -- 🔹 4️⃣ Pobranie i przetworzenie wszystkich walut
    OPEN c_waluty;
    LOOP
        FETCH c_waluty INTO v_kod_waluty;
        EXIT WHEN c_waluty%NOTFOUND;

        BEGIN
            -- 🔹 Wywołanie procedury dla każdej waluty
            dodaj_zestawienie_walutowe(v_id_lista_zestawien, v_kod_waluty, p_data_od, p_data_do);
            
            -- 🔹 Logowanie sukcesu dla danej waluty
            loguj_informacje('INFO', 'Zestawienie dla waluty ' || v_kod_waluty || ' wygenerowane pomyślnie.');
        EXCEPTION
            WHEN OTHERS THEN
                -- 🔹 Logowanie błędu dla danej waluty
                loguj_informacje('ERROR', 'Błąd podczas generowania zestawienia dla waluty ' || v_kod_waluty || ': ' || SQLERRM);
        END;
    END LOOP;
    CLOSE c_waluty;

    -- 🔹 5️⃣ Potwierdzenie zakończenia procedury
    loguj_informacje('INFO', 'Zakończono generowanie zestawień dla wszystkich walut.');

EXCEPTION
    WHEN OTHERS THEN
        loguj_informacje('ERROR', 'Błąd w procedurze generuj_zestawienia_dla_wszystkich_walut: ' || SQLERRM);
        ROLLBACK;
        RAISE;
END;
/


-- Testtowanie 
BEGIN
    generuj_zestawienia_dla_wszystkich_walut('Zestawienie ultum Styczeń 2025', TO_DATE('2025-01-01', 'YYYY-MM-DD'), TO_DATE('2025-01-23', 'YYYY-MM-DD'));
END;
/

SELECT * FROM lista_zestawien ORDER BY data_utworzenia DESC;
SELECT * FROM zestawienia  WHERE ID_LISTA_ZESTAWIEN =3;
SELECT * FROM logi_operacji ORDER BY data_utworzenia DESC;

